# -*- coding: utf-8 -*-
"""
Clasificador de Autos CNN - Versi√≥n PyTorch
Basado en el estilo del profesor - Compatible con macOS
Autor: David Timana | Curso: Visi√≥n por Computador
"""

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
import numpy as np
import matplotlib.pyplot as plt
from torch.utils.data import DataLoader
import warnings
warnings.filterwarnings('ignore')

print("üöó CLASIFICADOR DE AUTOS CNN - VERSI√ìN PYTORCH")
print("=" * 50)

# Verificar configuraci√≥n
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"‚úÖ PyTorch version: {torch.__version__}")
print(f"‚úÖ Device: {device}")

# =============================================================================
# 1. CARGAR DATASET CIFAR-10
# =============================================================================
print("\n1. Cargando dataset CIFAR-10...")

# Transformaciones para preprocesamiento
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
])

# Cargar datasets
trainset = torchvision.datasets.CIFAR10(root='./data', train=True,
                                       download=True, transform=transform)
testset = torchvision.datasets.CIFAR10(root='./data', train=False,
                                      download=True, transform=transform)

# Crear dataloaders (sin multiprocessing para compatibilidad con macOS)
trainloader = DataLoader(trainset, batch_size=64, shuffle=True, num_workers=0)
testloader = DataLoader(testset, batch_size=64, shuffle=False, num_workers=0)

# Clases disponibles
classes = ('avi√≥n', 'autom√≥vil', 'p√°jaro', 'gato', 'ciervo', 
           'perro', 'rana', 'caballo', 'barco', 'cami√≥n')

print(f"‚úÖ Dataset cargado:")
print(f"   üìä Entrenamiento: {len(trainset):,} im√°genes")
print(f"   üìä Prueba: {len(testset):,} im√°genes")
print(f"   üñºÔ∏è  Tama√±o: 32x32x3")
print(f"   üè∑Ô∏è  Clases: 10")
print(f"   üìù Clases: {classes}")
print(f"   üöó Autom√≥viles: clase 1")

# =============================================================================
# 2. DEFINIR MODELO CNN
# =============================================================================
print("\n2. Construyendo modelo CNN...")

class CNN(nn.Module):
    def __init__(self):
        super(CNN, self).__init__()
        # Primera capa convolucional
        self.conv1 = nn.Conv2d(3, 32, 3, padding=1)
        self.pool = nn.MaxPool2d(2, 2)
        self.relu = nn.ReLU()
        
        # Segunda capa convolucional
        self.conv2 = nn.Conv2d(32, 64, 3, padding=1)
        
        # Tercera capa convolucional
        self.conv3 = nn.Conv2d(64, 128, 3, padding=1)
        
        # Capas densas
        self.fc1 = nn.Linear(128 * 4 * 4, 256)
        self.fc2 = nn.Linear(256, 128)
        self.fc3 = nn.Linear(128, 10)
        self.dropout = nn.Dropout(0.5)
        
    def forward(self, x):
        # Primera capa convolucional
        x = self.pool(self.relu(self.conv1(x)))  # 32x32 -> 16x16
        
        # Segunda capa convolucional
        x = self.pool(self.relu(self.conv2(x)))  # 16x16 -> 8x8
        
        # Tercera capa convolucional
        x = self.pool(self.relu(self.conv3(x)))  # 8x8 -> 4x4
        
        # Aplanar
        x = x.view(-1, 128 * 4 * 4)
        
        # Capas densas
        x = self.relu(self.fc1(x))
        x = self.dropout(x)
        x = self.relu(self.fc2(x))
        x = self.dropout(x)
        x = self.fc3(x)
        
        return x

# Crear modelo
model = CNN().to(device)
print("‚úÖ Modelo creado:")
print(model)

# =============================================================================
# 3. DEFINIR FUNCI√ìN DE P√âRDIDA Y OPTIMIZADOR
# =============================================================================
print("\n3. Configurando entrenamiento...")

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

print(f"‚úÖ Funci√≥n de p√©rdida: CrossEntropyLoss")
print(f"‚úÖ Optimizador: Adam (lr=0.001)")

# =============================================================================
# 4. ENTRENAR MODELO
# =============================================================================
print("\n4. Entrenando modelo...")

def train_model(epochs=10):
    train_losses = []
    train_accuracies = []
    
    for epoch in range(epochs):
        model.train()
        running_loss = 0.0
        correct = 0
        total = 0
        
        print(f"üöÄ √âpoca {epoch+1}/{epochs}")
        
        for i, data in enumerate(trainloader, 0):
            inputs, labels = data[0].to(device), data[1].to(device)
            
            # Zero the parameter gradients
            optimizer.zero_grad()
            
            # Forward + backward + optimize
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            
            # Estad√≠sticas
            running_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
            
            # Mostrar progreso cada 100 batches
            if i % 100 == 99:
                print(f'   Batch {i+1}, Loss: {running_loss/100:.3f}, Accuracy: {100*correct/total:.2f}%')
                running_loss = 0.0
        
        # Calcular accuracy de la √©poca
        epoch_accuracy = 100 * correct / total
        train_accuracies.append(epoch_accuracy)
        train_losses.append(running_loss / len(trainloader))
        
        print(f"‚úÖ √âpoca {epoch+1} completada - Accuracy: {epoch_accuracy:.2f}%")
    
    return train_losses, train_accuracies

# Entrenar modelo
print("üöÄ Iniciando entrenamiento...")
train_losses, train_accuracies = train_model(epochs=10)
print("‚úÖ Entrenamiento completado!")

# =============================================================================
# 5. EVALUAR MODELO
# =============================================================================
print("\n5. Evaluando modelo...")

def evaluate_model():
    model.eval()
    correct = 0
    total = 0
    class_correct = list(0. for i in range(10))
    class_total = list(0. for i in range(10))
    
    with torch.no_grad():
        for data in testloader:
            images, labels = data[0].to(device), data[1].to(device)
            outputs = model(images)
            _, predicted = torch.max(outputs, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
            
            # Accuracy por clase
            c = (predicted == labels).squeeze()
            for i in range(len(labels)):
                label = labels[i]
                class_correct[label] += c[i].item()
                class_total[label] += 1
    
    # Accuracy general
    test_accuracy = 100 * correct / total
    print(f"üìà Resultados:")
    print(f"   ‚úÖ Test accuracy: {test_accuracy:.2f}%")
    
    # Accuracy por clase
    print(f"üìä Accuracy por clase:")
    for i in range(10):
        if class_total[i] > 0:
            class_accuracy = 100 * class_correct[i] / class_total[i]
            print(f"   {i:2d}. {classes[i]:10s}: {class_accuracy:.2f}%")
    
    return test_accuracy, class_correct, class_total

test_accuracy, class_correct, class_total = evaluate_model()

# =============================================================================
# 6. VISUALIZAR RESULTADOS
# =============================================================================
print("\n6. Visualizando resultados...")

# Gr√°fico de accuracy durante entrenamiento
plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(range(1, len(train_accuracies)+1), train_accuracies, 'b-', label='Train Accuracy')
plt.title('Accuracy durante Entrenamiento')
plt.xlabel('√âpoca')
plt.ylabel('Accuracy (%)')
plt.legend()
plt.grid(True)

# Gr√°fico de accuracy por clase
plt.subplot(1, 2, 2)
class_accuracies = [100 * class_correct[i] / class_total[i] if class_total[i] > 0 else 0 for i in range(10)]
bars = plt.bar(range(10), class_accuracies, color='orange')
plt.title('Accuracy por Clase')
plt.xlabel('Clase')
plt.ylabel('Accuracy (%)')
plt.xticks(range(10), [f'{i}\n{name[:3]}' for i, name in enumerate(classes)], fontsize=8)

# Agregar valores en las barras
for i, bar in enumerate(bars):
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2., height + 1,
             f'{height:.1f}%', ha='center', va='bottom', fontsize=8)

plt.tight_layout()
plt.show()

print("‚úÖ Visualizaciones completadas!")

# =============================================================================
# 7. PREDICCIONES EN IM√ÅGENES ESPEC√çFICAS
# =============================================================================
print("\n7. Predicciones en im√°genes espec√≠ficas...")

def show_predictions():
    model.eval()
    
    # Obtener algunas im√°genes de prueba
    dataiter = iter(testloader)
    images, labels = next(dataiter)
    
    # Mostrar primeras 5 im√°genes
    plt.figure(figsize=(15, 3))
    for i in range(5):
        plt.subplot(1, 5, i+1)
        
        # Desnormalizar imagen
        img = images[i] / 2 + 0.5
        img = img.permute(1, 2, 0).cpu().numpy()
        plt.imshow(img)
        
        # Hacer predicci√≥n
        with torch.no_grad():
            output = model(images[i:i+1].to(device))
            _, predicted = torch.max(output, 1)
            confidence = torch.softmax(output, dim=1).max().item()
        
        plt.title(f'Real: {classes[labels[i]]}\nPred: {classes[predicted[0]]}\nConf: {confidence:.2f}')
        plt.axis('off')
    
    plt.suptitle('Predicciones en Im√°genes de Prueba', fontsize=16)
    plt.tight_layout()
    plt.show()

show_predictions()
print("‚úÖ Predicciones completadas!")

# =============================================================================
# 8. AN√ÅLISIS DE CLASE ESPEC√çFICA (AUTOM√ìVILES)
# =============================================================================
print("\n8. An√°lisis espec√≠fico de autom√≥viles...")

def analyze_cars():
    model.eval()
    car_correct = 0
    car_total = 0
    
    with torch.no_grad():
        for data in testloader:
            images, labels = data[0].to(device), data[1].to(device)
            
            # Filtrar solo autom√≥viles (clase 1)
            car_mask = (labels == 1)
            if car_mask.sum() > 0:
                car_images = images[car_mask]
                car_labels = labels[car_mask]
                
                outputs = model(car_images)
                _, predicted = torch.max(outputs, 1)
                
                car_total += car_labels.size(0)
                car_correct += (predicted == car_labels).sum().item()
    
    if car_total > 0:
        car_accuracy = 100 * car_correct / car_total
        print(f"üöó Autom√≥viles en conjunto de prueba: {car_total}")
        print(f"‚úÖ Precisi√≥n en autom√≥viles: {car_accuracy:.2f}%")
        return car_accuracy
    else:
        print("‚ùå No se encontraron autom√≥viles en el conjunto de prueba")
        return 0

car_accuracy = analyze_cars()

# =============================================================================
# 9. GUARDAR MODELO
# =============================================================================
print("\n9. Guardando modelo...")

torch.save(model.state_dict(), 'modelo_autos_cnn_pytorch.pth')
print("‚úÖ Modelo guardado como 'modelo_autos_cnn_pytorch.pth'")

# =============================================================================
# RESUMEN FINAL
# =============================================================================
print("\n" + "=" * 50)
print("üéâ ENTRENAMIENTO COMPLETADO")
print("=" * 50)
print(f"üìä Test accuracy: {test_accuracy:.2f}%")
print(f"üè∑Ô∏è  Clases: 10 (incluyendo autom√≥viles)")
print(f"üß† Modelo: CNN (PyTorch)")
print(f"üíª Device: {device}")
print(f"üöó Precisi√≥n en autom√≥viles: {car_accuracy:.2f}%")
print(f"üíæ Modelo guardado: modelo_autos_cnn_pytorch.pth")

print("\nüéØ El modelo puede clasificar:")
for i, name in enumerate(classes):
    print(f"   {i}. {name}")

print("\n‚úÖ ¬°Proyecto completado exitosamente con PyTorch!")
print("üöÄ Ventajas de PyTorch:")
print("   - ‚úÖ Excelente compatibilidad con macOS")
print("   - ‚úÖ Sintaxis m√°s intuitiva")
print("   - ‚úÖ Debugging m√°s f√°cil")
print("   - ‚úÖ Flexibilidad en el dise√±o de modelos")
print("   - ‚úÖ Gran comunidad y documentaci√≥n")

# =============================================================================
# PROTECCI√ìN PARA MULTIPROCESSING EN MACOS
# =============================================================================
if __name__ == '__main__':
    # El c√≥digo principal ya se ejecut√≥ arriba
    pass
